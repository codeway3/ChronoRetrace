# ChronoRetrace å®‰å…¨é…ç½®æŒ‡å—

æœ¬æ–‡æ¡£æä¾› ChronoRetrace åº”ç”¨çš„å…¨é¢å®‰å…¨é…ç½®æŒ‡å—ï¼ŒåŒ…æ‹¬åº”ç”¨å®‰å…¨ã€åŸºç¡€è®¾æ–½å®‰å…¨ã€æ•°æ®ä¿æŠ¤å’Œåˆè§„è¦æ±‚ç­‰å†…å®¹ã€‚

## ç›®å½•

- [å®‰å…¨æ¶æ„æ¦‚è¿°](#å®‰å…¨æ¶æ„æ¦‚è¿°)
- [èº«ä»½è®¤è¯ä¸æˆæƒ](#èº«ä»½è®¤è¯ä¸æˆæƒ)
- [ç½‘ç»œå®‰å…¨](#ç½‘ç»œå®‰å…¨)
- [æ•°æ®ä¿æŠ¤](#æ•°æ®ä¿æŠ¤)
- [åº”ç”¨å®‰å…¨](#åº”ç”¨å®‰å…¨)
- [åŸºç¡€è®¾æ–½å®‰å…¨](#åŸºç¡€è®¾æ–½å®‰å…¨)
- [ç›‘æ§ä¸å®¡è®¡](#ç›‘æ§ä¸å®¡è®¡)
- [åˆè§„è¦æ±‚](#åˆè§„è¦æ±‚)
- [å®‰å…¨äº‹ä»¶å“åº”](#å®‰å…¨äº‹ä»¶å“åº”)
- [å®‰å…¨æµ‹è¯•](#å®‰å…¨æµ‹è¯•)

## å®‰å…¨æ¶æ„æ¦‚è¿°

### å®‰å…¨å±‚æ¬¡æ¨¡å‹
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              ç”¨æˆ·å±‚                      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              åº”ç”¨å±‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   å‰ç«¯åº”ç”¨   â”‚  â”‚    åç«¯ API     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              ç½‘ç»œå±‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  è´Ÿè½½å‡è¡¡å™¨  â”‚  â”‚   é˜²ç«å¢™/WAF    â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚              æ•°æ®å±‚                      â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚   æ•°æ®åº“    â”‚  â”‚      ç¼“å­˜       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚            åŸºç¡€è®¾æ–½å±‚                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚  å®¹å™¨å¹³å°   â”‚  â”‚    æ“ä½œç³»ç»Ÿ     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### å®‰å…¨åŸåˆ™
1. **æœ€å°æƒé™åŸåˆ™**: ç”¨æˆ·å’ŒæœåŠ¡åªè·å¾—å®Œæˆä»»åŠ¡æ‰€éœ€çš„æœ€å°æƒé™
2. **æ·±åº¦é˜²å¾¡**: å¤šå±‚å®‰å…¨æ§åˆ¶ï¼Œé¿å…å•ç‚¹æ•…éšœ
3. **é›¶ä¿¡ä»»æ¶æ„**: ä¸ä¿¡ä»»ä»»ä½•ç½‘ç»œä½ç½®ï¼ŒéªŒè¯æ‰€æœ‰è®¿é—®
4. **æ•°æ®åˆ†ç±»**: æ ¹æ®æ•æ„Ÿæ€§å¯¹æ•°æ®è¿›è¡Œåˆ†ç±»å’Œä¿æŠ¤
5. **æŒç»­ç›‘æ§**: å®æ—¶ç›‘æ§å’Œå®¡è®¡æ‰€æœ‰å®‰å…¨äº‹ä»¶

## èº«ä»½è®¤è¯ä¸æˆæƒ

### JWT è®¤è¯é…ç½®

#### JWT å®‰å…¨é…ç½®
```python
# jwt_config.py
import jwt
import datetime
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa

class JWTConfig:
    def __init__(self):
        # ä½¿ç”¨ RS256 ç®—æ³•ï¼ˆéå¯¹ç§°åŠ å¯†ï¼‰
        self.algorithm = 'RS256'
        self.access_token_expire = datetime.timedelta(minutes=15)
        self.refresh_token_expire = datetime.timedelta(days=7)
        
        # ç”Ÿæˆ RSA å¯†é’¥å¯¹
        self.private_key = rsa.generate_private_key(
            public_exponent=65537,
            key_size=2048
        )
        self.public_key = self.private_key.public_key()
    
    def generate_token(self, user_id, permissions=None, token_type='access'):
        """ç”Ÿæˆ JWT ä»¤ç‰Œ"""
        now = datetime.datetime.utcnow()
        
        if token_type == 'access':
            expire = now + self.access_token_expire
        else:
            expire = now + self.refresh_token_expire
        
        payload = {
            'user_id': user_id,
            'permissions': permissions or [],
            'token_type': token_type,
            'iat': now,
            'exp': expire,
            'jti': str(uuid.uuid4())  # JWT IDï¼Œç”¨äºä»¤ç‰Œæ’¤é”€
        }
        
        private_pem = self.private_key.private_bytes(
            encoding=serialization.Encoding.PEM,
            format=serialization.PrivateFormat.PKCS8,
            encryption_algorithm=serialization.NoEncryption()
        )
        
        return jwt.encode(payload, private_pem, algorithm=self.algorithm)
    
    def verify_token(self, token):
        """éªŒè¯ JWT ä»¤ç‰Œ"""
        try:
            public_pem = self.public_key.public_bytes(
                encoding=serialization.Encoding.PEM,
                format=serialization.PublicFormat.SubjectPublicKeyInfo
            )
            
            payload = jwt.decode(token, public_pem, algorithms=[self.algorithm])
            
            # æ£€æŸ¥ä»¤ç‰Œæ˜¯å¦åœ¨é»‘åå•ä¸­
            if self.is_token_blacklisted(payload.get('jti')):
                raise jwt.InvalidTokenError('Token is blacklisted')
            
            return payload
        except jwt.ExpiredSignatureError:
            raise jwt.InvalidTokenError('Token has expired')
        except jwt.InvalidTokenError:
            raise jwt.InvalidTokenError('Invalid token')
```

#### æƒé™æ§åˆ¶ç³»ç»Ÿ
```python
# rbac.py
from enum import Enum
from functools import wraps

class Permission(Enum):
    READ_USER = 'read:user'
    WRITE_USER = 'write:user'
    DELETE_USER = 'delete:user'
    READ_ADMIN = 'read:admin'
    WRITE_ADMIN = 'write:admin'
    SYSTEM_CONFIG = 'system:config'

class Role(Enum):
    USER = 'user'
    MODERATOR = 'moderator'
    ADMIN = 'admin'
    SUPER_ADMIN = 'super_admin'

# è§’è‰²æƒé™æ˜ å°„
ROLE_PERMISSIONS = {
    Role.USER: [
        Permission.READ_USER
    ],
    Role.MODERATOR: [
        Permission.READ_USER,
        Permission.WRITE_USER
    ],
    Role.ADMIN: [
        Permission.READ_USER,
        Permission.WRITE_USER,
        Permission.DELETE_USER,
        Permission.READ_ADMIN
    ],
    Role.SUPER_ADMIN: [
        Permission.READ_USER,
        Permission.WRITE_USER,
        Permission.DELETE_USER,
        Permission.READ_ADMIN,
        Permission.WRITE_ADMIN,
        Permission.SYSTEM_CONFIG
    ]
}

def require_permission(permission):
    """æƒé™è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            # ä»è¯·æ±‚ä¸­è·å–ç”¨æˆ·æƒé™
            user_permissions = get_current_user_permissions()
            
            if permission.value not in user_permissions:
                raise PermissionError(f'Required permission: {permission.value}')
            
            return func(*args, **kwargs)
        return wrapper
    return decorator

def require_role(role):
    """è§’è‰²è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            user_role = get_current_user_role()
            required_permissions = ROLE_PERMISSIONS.get(role, [])
            user_permissions = get_current_user_permissions()
            
            if not all(perm.value in user_permissions for perm in required_permissions):
                raise PermissionError(f'Required role: {role.value}')
            
            return func(*args, **kwargs)
        return wrapper
    return decorator
```

### å¤šå› ç´ è®¤è¯ (MFA)

#### TOTP å®ç°
```python
# mfa.py
import pyotp
import qrcode
import io
import base64
from cryptography.fernet import Fernet

class MFAManager:
    def __init__(self, encryption_key):
        self.cipher = Fernet(encryption_key)
    
    def generate_secret(self, user_id):
        """ä¸ºç”¨æˆ·ç”Ÿæˆ TOTP å¯†é’¥"""
        secret = pyotp.random_base32()
        
        # åŠ å¯†å­˜å‚¨å¯†é’¥
        encrypted_secret = self.cipher.encrypt(secret.encode())
        
        # ä¿å­˜åˆ°æ•°æ®åº“
        self.save_user_mfa_secret(user_id, encrypted_secret)
        
        return secret
    
    def generate_qr_code(self, user_email, secret):
        """ç”Ÿæˆ QR ç """
        totp_uri = pyotp.totp.TOTP(secret).provisioning_uri(
            name=user_email,
            issuer_name='ChronoRetrace'
        )
        
        qr = qrcode.QRCode(version=1, box_size=10, border=5)
        qr.add_data(totp_uri)
        qr.make(fit=True)
        
        img = qr.make_image(fill_color='black', back_color='white')
        
        # è½¬æ¢ä¸º base64
        buffer = io.BytesIO()
        img.save(buffer, format='PNG')
        img_str = base64.b64encode(buffer.getvalue()).decode()
        
        return f'data:image/png;base64,{img_str}'
    
    def verify_totp(self, user_id, token):
        """éªŒè¯ TOTP ä»¤ç‰Œ"""
        # è·å–ç”¨æˆ·çš„åŠ å¯†å¯†é’¥
        encrypted_secret = self.get_user_mfa_secret(user_id)
        if not encrypted_secret:
            return False
        
        # è§£å¯†å¯†é’¥
        secret = self.cipher.decrypt(encrypted_secret).decode()
        
        # éªŒè¯ä»¤ç‰Œ
        totp = pyotp.TOTP(secret)
        return totp.verify(token, valid_window=1)  # å…è®¸å‰å30ç§’çš„æ—¶é—´çª—å£
    
    def generate_backup_codes(self, user_id):
        """ç”Ÿæˆå¤‡ç”¨æ¢å¤ç """
        codes = []
        for _ in range(10):
            code = ''.join(random.choices(string.ascii_uppercase + string.digits, k=8))
            codes.append(code)
        
        # åŠ å¯†å­˜å‚¨å¤‡ç”¨ç 
        encrypted_codes = [self.cipher.encrypt(code.encode()) for code in codes]
        self.save_user_backup_codes(user_id, encrypted_codes)
        
        return codes
```

## ç½‘ç»œå®‰å…¨

### é˜²ç«å¢™é…ç½®

#### iptables è§„åˆ™
```bash
#!/bin/bash
# firewall_rules.sh

# æ¸…é™¤ç°æœ‰è§„åˆ™
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# è®¾ç½®é»˜è®¤ç­–ç•¥
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# å…è®¸æœ¬åœ°å›ç¯
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# å…è®¸å·²å»ºç«‹çš„è¿æ¥
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# SSH è®¿é—®ï¼ˆé™åˆ¶æº IPï¼‰
iptables -A INPUT -p tcp --dport 22 -s 192.168.1.0/24 -m state --state NEW -j ACCEPT
iptables -A INPUT -p tcp --dport 22 -s 10.0.0.0/8 -m state --state NEW -j ACCEPT

# HTTP/HTTPS è®¿é—®
iptables -A INPUT -p tcp --dport 80 -m state --state NEW -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -m state --state NEW -j ACCEPT

# åº”ç”¨ç«¯å£ï¼ˆä»…å†…ç½‘è®¿é—®ï¼‰
iptables -A INPUT -p tcp --dport 8000 -s 10.0.0.0/8 -m state --state NEW -j ACCEPT
iptables -A INPUT -p tcp --dport 3000 -s 10.0.0.0/8 -m state --state NEW -j ACCEPT

# æ•°æ®åº“ç«¯å£ï¼ˆä»…åº”ç”¨æœåŠ¡å™¨è®¿é—®ï¼‰
iptables -A INPUT -p tcp --dport 5432 -s 10.0.1.0/24 -m state --state NEW -j ACCEPT
iptables -A INPUT -p tcp --dport 6379 -s 10.0.1.0/24 -m state --state NEW -j ACCEPT

# ç›‘æ§ç«¯å£ï¼ˆä»…ç›‘æ§æœåŠ¡å™¨è®¿é—®ï¼‰
iptables -A INPUT -p tcp --dport 9090 -s 10.0.2.0/24 -m state --state NEW -j ACCEPT
iptables -A INPUT -p tcp --dport 3001 -s 10.0.2.0/24 -m state --state NEW -j ACCEPT

# é˜²æ­¢ DDoS æ”»å‡»
iptables -A INPUT -p tcp --dport 80 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -m limit --limit 25/minute --limit-burst 100 -j ACCEPT

# é˜²æ­¢ç«¯å£æ‰«æ
iptables -A INPUT -m recent --name portscan --rcheck --seconds 86400 -j DROP
iptables -A INPUT -m recent --name portscan --remove
iptables -A INPUT -p tcp -m tcp --dport 139 -m recent --name portscan --set -j LOG --log-prefix "portscan:"
iptables -A INPUT -p tcp -m tcp --dport 139 -m recent --name portscan --set -j DROP

# è®°å½•è¢«ä¸¢å¼ƒçš„åŒ…
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables denied: " --log-level 7

# ä¿å­˜è§„åˆ™
iptables-save > /etc/iptables/rules.v4
ip6tables-save > /etc/iptables/rules.v6
```

### WAF é…ç½®

#### ModSecurity è§„åˆ™
```apache
# modsecurity.conf

# åŸºç¡€é…ç½®
SecRuleEngine On
SecRequestBodyAccess On
SecResponseBodyAccess Off
SecRequestBodyLimit 13107200
SecRequestBodyNoFilesLimit 131072
SecRequestBodyInMemoryLimit 131072
SecRequestBodyLimitAction Reject

# å®¡è®¡æ—¥å¿—
SecAuditEngine RelevantOnly
SecAuditLogRelevantStatus "^(?:5|4(?!04))"
SecAuditLogParts ABIJDEFHZ
SecAuditLogType Serial
SecAuditLog /var/log/modsec_audit.log

# æ ¸å¿ƒè§„åˆ™é›†
Include /etc/modsecurity/crs/crs-setup.conf
Include /etc/modsecurity/crs/rules/*.conf

# è‡ªå®šä¹‰è§„åˆ™
# é˜²æ­¢ SQL æ³¨å…¥
SecRule ARGS "@detectSQLi" \
    "id:1001,\
    phase:2,\
    block,\
    msg:'SQL Injection Attack Detected',\
    logdata:'Matched Data: %{MATCHED_VAR} found within %{MATCHED_VAR_NAME}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'platform-multi',\
    tag:'attack-sqli'"

# é˜²æ­¢ XSS æ”»å‡»
SecRule ARGS "@detectXSS" \
    "id:1002,\
    phase:2,\
    block,\
    msg:'XSS Attack Detected',\
    logdata:'Matched Data: %{MATCHED_VAR} found within %{MATCHED_VAR_NAME}',\
    tag:'application-multi',\
    tag:'language-multi',\
    tag:'platform-multi',\
    tag:'attack-xss'"

# é™åˆ¶è¯·æ±‚é¢‘ç‡
SecRule IP:REQUEST_COUNT "@gt 100" \
    "id:1003,\
    phase:1,\
    deny,\
    status:429,\
    msg:'Rate limit exceeded',\
    expirevar:IP:REQUEST_COUNT=60"

SecAction "id:1004,phase:1,initcol:IP=%{REMOTE_ADDR},setvar:IP.REQUEST_COUNT=+1"
```

### TLS/SSL é…ç½®

#### Nginx SSL é…ç½®
```nginx
# nginx_ssl.conf
server {
    listen 443 ssl http2;
    server_name chronoretrace.com;
    
    # SSL è¯ä¹¦
    ssl_certificate /etc/ssl/certs/chronoretrace.crt;
    ssl_certificate_key /etc/ssl/private/chronoretrace.key;
    
    # SSL åè®®å’ŒåŠ å¯†å¥—ä»¶
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # SSL ä¼šè¯
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 10m;
    ssl_session_tickets off;
    
    # OCSP Stapling
    ssl_stapling on;
    ssl_stapling_verify on;
    ssl_trusted_certificate /etc/ssl/certs/ca-certificates.crt;
    resolver 8.8.8.8 8.8.4.4 valid=300s;
    resolver_timeout 5s;
    
    # å®‰å…¨å¤´
    add_header Strict-Transport-Security "max-age=31536000; includeSubDomains; preload" always;
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "default-src 'self'; script-src 'self' 'unsafe-inline'; style-src 'self' 'unsafe-inline'; img-src 'self' data: https:; font-src 'self'; connect-src 'self'; frame-ancestors 'none';" always;
    
    # éšè—æœåŠ¡å™¨ä¿¡æ¯
    server_tokens off;
    
    location / {
        proxy_pass http://backend;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # å®‰å…¨å¤´
        proxy_hide_header X-Powered-By;
        proxy_hide_header Server;
    }
}

# å¼ºåˆ¶ HTTPS é‡å®šå‘
server {
    listen 80;
    server_name chronoretrace.com;
    return 301 https://$server_name$request_uri;
}
```

## æ•°æ®ä¿æŠ¤

### æ•°æ®åŠ å¯†

#### æ•°æ®åº“åŠ å¯†
```sql
-- PostgreSQL é€æ˜æ•°æ®åŠ å¯†é…ç½®

-- å¯ç”¨ pgcrypto æ‰©å±•
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- åˆ›å»ºåŠ å¯†å‡½æ•°
CREATE OR REPLACE FUNCTION encrypt_sensitive_data(data TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN encode(encrypt(data::bytea, 'encryption_key', 'aes'), 'base64');
END;
$$ LANGUAGE plpgsql;

CREATE OR REPLACE FUNCTION decrypt_sensitive_data(encrypted_data TEXT)
RETURNS TEXT AS $$
BEGIN
    RETURN convert_from(decrypt(decode(encrypted_data, 'base64'), 'encryption_key', 'aes'), 'UTF8');
END;
$$ LANGUAGE plpgsql;

-- åˆ›å»ºåŠ å¯†è¡¨
CREATE TABLE users (
    id SERIAL PRIMARY KEY,
    username VARCHAR(255) NOT NULL,
    email VARCHAR(255) NOT NULL,
    password_hash VARCHAR(255) NOT NULL,
    phone_encrypted TEXT,  -- åŠ å¯†å­˜å‚¨
    ssn_encrypted TEXT,    -- åŠ å¯†å­˜å‚¨
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
);

-- æ’å…¥åŠ å¯†æ•°æ®
INSERT INTO users (username, email, password_hash, phone_encrypted, ssn_encrypted)
VALUES (
    'john_doe',
    'john@example.com',
    '$2b$12$...',  -- bcrypt å“ˆå¸Œ
    encrypt_sensitive_data('123-456-7890'),
    encrypt_sensitive_data('123-45-6789')
);

-- æŸ¥è¯¢è§£å¯†æ•°æ®
SELECT 
    username,
    email,
    decrypt_sensitive_data(phone_encrypted) AS phone,
    decrypt_sensitive_data(ssn_encrypted) AS ssn
FROM users
WHERE id = 1;
```

#### åº”ç”¨å±‚åŠ å¯†
```python
# encryption.py
from cryptography.fernet import Fernet
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.kdf.pbkdf2 import PBKDF2HMAC
import base64
import os

class DataEncryption:
    def __init__(self, password=None):
        if password:
            self.key = self._derive_key(password)
        else:
            self.key = Fernet.generate_key()
        self.cipher = Fernet(self.key)
    
    def _derive_key(self, password):
        """ä»å¯†ç æ´¾ç”ŸåŠ å¯†å¯†é’¥"""
        salt = os.urandom(16)
        kdf = PBKDF2HMAC(
            algorithm=hashes.SHA256(),
            length=32,
            salt=salt,
            iterations=100000,
        )
        key = base64.urlsafe_b64encode(kdf.derive(password.encode()))
        return key
    
    def encrypt(self, data):
        """åŠ å¯†æ•°æ®"""
        if isinstance(data, str):
            data = data.encode()
        return self.cipher.encrypt(data)
    
    def decrypt(self, encrypted_data):
        """è§£å¯†æ•°æ®"""
        decrypted = self.cipher.decrypt(encrypted_data)
        return decrypted.decode()
    
    def encrypt_file(self, file_path):
        """åŠ å¯†æ–‡ä»¶"""
        with open(file_path, 'rb') as file:
            file_data = file.read()
        
        encrypted_data = self.cipher.encrypt(file_data)
        
        with open(f"{file_path}.encrypted", 'wb') as file:
            file.write(encrypted_data)
    
    def decrypt_file(self, encrypted_file_path, output_path):
        """è§£å¯†æ–‡ä»¶"""
        with open(encrypted_file_path, 'rb') as file:
            encrypted_data = file.read()
        
        decrypted_data = self.cipher.decrypt(encrypted_data)
        
        with open(output_path, 'wb') as file:
            file.write(decrypted_data)

# ä½¿ç”¨ç¤ºä¾‹
encryption = DataEncryption(password="your-secret-password")

# åŠ å¯†æ•æ„Ÿæ•°æ®
sensitive_data = "ç”¨æˆ·èº«ä»½è¯å·ç : 123456789012345678"
encrypted = encryption.encrypt(sensitive_data)

# è§£å¯†æ•°æ®
decrypted = encryption.decrypt(encrypted)
print(decrypted)
```

### æ•°æ®è„±æ•

#### æ•æ„Ÿæ•°æ®è„±æ•
```python
# data_masking.py
import re
import hashlib

class DataMasking:
    @staticmethod
    def mask_email(email):
        """é‚®ç®±è„±æ•"""
        if '@' not in email:
            return email
        
        local, domain = email.split('@', 1)
        if len(local) <= 2:
            masked_local = '*' * len(local)
        else:
            masked_local = local[0] + '*' * (len(local) - 2) + local[-1]
        
        return f"{masked_local}@{domain}"
    
    @staticmethod
    def mask_phone(phone):
        """æ‰‹æœºå·è„±æ•"""
        phone = re.sub(r'\D', '', phone)  # ç§»é™¤éæ•°å­—å­—ç¬¦
        if len(phone) >= 7:
            return phone[:3] + '*' * (len(phone) - 6) + phone[-3:]
        return '*' * len(phone)
    
    @staticmethod
    def mask_id_card(id_card):
        """èº«ä»½è¯å·è„±æ•"""
        if len(id_card) >= 8:
            return id_card[:4] + '*' * (len(id_card) - 8) + id_card[-4:]
        return '*' * len(id_card)
    
    @staticmethod
    def mask_credit_card(card_number):
        """ä¿¡ç”¨å¡å·è„±æ•"""
        card_number = re.sub(r'\D', '', card_number)
        if len(card_number) >= 8:
            return card_number[:4] + '*' * (len(card_number) - 8) + card_number[-4:]
        return '*' * len(card_number)
    
    @staticmethod
    def hash_sensitive_data(data, salt=None):
        """æ•æ„Ÿæ•°æ®å“ˆå¸ŒåŒ–"""
        if salt is None:
            salt = 'default_salt'
        
        combined = f"{data}{salt}"
        return hashlib.sha256(combined.encode()).hexdigest()
    
    @staticmethod
    def mask_ip_address(ip):
        """IP åœ°å€è„±æ•"""
        parts = ip.split('.')
        if len(parts) == 4:
            return f"{parts[0]}.{parts[1]}.*.* "
        return ip

# ä½¿ç”¨ç¤ºä¾‹
masking = DataMasking()

print(masking.mask_email("user@example.com"))  # u**r@example.com
print(masking.mask_phone("13812345678"))       # 138****5678
print(masking.mask_id_card("123456789012345678"))  # 1234**********5678
print(masking.mask_credit_card("1234567890123456"))  # 1234********3456
```

## åº”ç”¨å®‰å…¨

### è¾“å…¥éªŒè¯å’Œæ¸…ç†

#### è¾“å…¥éªŒè¯æ¡†æ¶
```python
# input_validation.py
import re
from typing import Any, Dict, List
from html import escape
import bleach

class InputValidator:
    def __init__(self):
        self.patterns = {
            'email': r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
            'phone': r'^\+?[1-9]\d{1,14}$',
            'username': r'^[a-zA-Z0-9_]{3,20}$',
            'password': r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$',
            'url': r'^https?://[^\s/$.?#].[^\s]*$',
            'ip': r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$'
        }
    
    def validate_email(self, email: str) -> bool:
        """éªŒè¯é‚®ç®±æ ¼å¼"""
        return bool(re.match(self.patterns['email'], email))
    
    def validate_password(self, password: str) -> Dict[str, Any]:
        """éªŒè¯å¯†ç å¼ºåº¦"""
        result = {
            'valid': False,
            'errors': []
        }
        
        if len(password) < 8:
            result['errors'].append('å¯†ç é•¿åº¦è‡³å°‘8ä½')
        
        if not re.search(r'[a-z]', password):
            result['errors'].append('å¯†ç å¿…é¡»åŒ…å«å°å†™å­—æ¯')
        
        if not re.search(r'[A-Z]', password):
            result['errors'].append('å¯†ç å¿…é¡»åŒ…å«å¤§å†™å­—æ¯')
        
        if not re.search(r'\d', password):
            result['errors'].append('å¯†ç å¿…é¡»åŒ…å«æ•°å­—')
        
        if not re.search(r'[@$!%*?&]', password):
            result['errors'].append('å¯†ç å¿…é¡»åŒ…å«ç‰¹æ®Šå­—ç¬¦')
        
        result['valid'] = len(result['errors']) == 0
        return result
    
    def sanitize_html(self, html_content: str) -> str:
        """æ¸…ç† HTML å†…å®¹"""
        allowed_tags = ['p', 'br', 'strong', 'em', 'u', 'ol', 'ul', 'li']
        allowed_attributes = {}
        
        return bleach.clean(html_content, tags=allowed_tags, attributes=allowed_attributes)
    
    def escape_sql(self, value: str) -> str:
        """SQL æ³¨å…¥é˜²æŠ¤"""
        # ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢æ˜¯æ›´å¥½çš„é€‰æ‹©ï¼Œè¿™é‡Œåªæ˜¯é¢å¤–çš„é˜²æŠ¤
        dangerous_chars = ["'", '"', ';', '--', '/*', '*/', 'xp_', 'sp_']
        for char in dangerous_chars:
            value = value.replace(char, '')
        return value
    
    def validate_file_upload(self, filename: str, content: bytes) -> Dict[str, Any]:
        """æ–‡ä»¶ä¸Šä¼ éªŒè¯"""
        result = {
            'valid': False,
            'errors': []
        }
        
        # æ£€æŸ¥æ–‡ä»¶æ‰©å±•å
        allowed_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.pdf', '.doc', '.docx']
        file_ext = filename.lower().split('.')[-1] if '.' in filename else ''
        
        if f'.{file_ext}' not in allowed_extensions:
            result['errors'].append(f'ä¸å…è®¸çš„æ–‡ä»¶ç±»å‹: {file_ext}')
        
        # æ£€æŸ¥æ–‡ä»¶å¤§å°ï¼ˆ10MB é™åˆ¶ï¼‰
        max_size = 10 * 1024 * 1024
        if len(content) > max_size:
            result['errors'].append('æ–‡ä»¶å¤§å°è¶…è¿‡é™åˆ¶')
        
        # æ£€æŸ¥æ–‡ä»¶å¤´ï¼ˆé­”æ•°ï¼‰
        file_signatures = {
            b'\xff\xd8\xff': 'jpg',
            b'\x89PNG\r\n\x1a\n': 'png',
            b'GIF87a': 'gif',
            b'GIF89a': 'gif',
            b'%PDF': 'pdf'
        }
        
        file_type_detected = None
        for signature, file_type in file_signatures.items():
            if content.startswith(signature):
                file_type_detected = file_type
                break
        
        if file_type_detected != file_ext:
            result['errors'].append('æ–‡ä»¶ç±»å‹ä¸æ‰©å±•åä¸åŒ¹é…')
        
        result['valid'] = len(result['errors']) == 0
        return result
```

### API å®‰å…¨

#### API é™æµå’Œé˜²æŠ¤
```python
# api_security.py
import time
import hashlib
from collections import defaultdict
from functools import wraps
from flask import request, jsonify

class RateLimiter:
    def __init__(self):
        self.requests = defaultdict(list)
        self.blocked_ips = set()
    
    def is_rate_limited(self, identifier, limit=100, window=3600):
        """æ£€æŸ¥æ˜¯å¦è¶…è¿‡é€Ÿç‡é™åˆ¶"""
        now = time.time()
        
        # æ¸…ç†è¿‡æœŸè®°å½•
        self.requests[identifier] = [
            req_time for req_time in self.requests[identifier]
            if now - req_time < window
        ]
        
        # æ£€æŸ¥è¯·æ±‚æ•°é‡
        if len(self.requests[identifier]) >= limit:
            return True
        
        # è®°å½•å½“å‰è¯·æ±‚
        self.requests[identifier].append(now)
        return False
    
    def block_ip(self, ip, duration=3600):
        """å°ç¦ IP"""
        self.blocked_ips.add((ip, time.time() + duration))
    
    def is_ip_blocked(self, ip):
        """æ£€æŸ¥ IP æ˜¯å¦è¢«å°ç¦"""
        now = time.time()
        # æ¸…ç†è¿‡æœŸå°ç¦
        self.blocked_ips = {
            (blocked_ip, expire_time) for blocked_ip, expire_time in self.blocked_ips
            if expire_time > now
        }
        
        return any(blocked_ip == ip for blocked_ip, _ in self.blocked_ips)

class APISecurityMiddleware:
    def __init__(self):
        self.rate_limiter = RateLimiter()
        self.suspicious_patterns = [
            r'<script[^>]*>.*?</script>',  # XSS
            r'union.*select',              # SQL æ³¨å…¥
            r'\.\./',                     # è·¯å¾„éå†
            r'eval\s*\(',                 # ä»£ç æ³¨å…¥
        ]
    
    def check_request_security(self, request):
        """æ£€æŸ¥è¯·æ±‚å®‰å…¨æ€§"""
        client_ip = request.remote_addr
        
        # æ£€æŸ¥ IP å°ç¦
        if self.rate_limiter.is_ip_blocked(client_ip):
            return {'blocked': True, 'reason': 'IP blocked'}
        
        # æ£€æŸ¥é€Ÿç‡é™åˆ¶
        if self.rate_limiter.is_rate_limited(client_ip):
            self.rate_limiter.block_ip(client_ip, 1800)  # å°ç¦30åˆ†é’Ÿ
            return {'blocked': True, 'reason': 'Rate limit exceeded'}
        
        # æ£€æŸ¥æ¶æ„æ¨¡å¼
        request_data = str(request.get_data())
        for pattern in self.suspicious_patterns:
            if re.search(pattern, request_data, re.IGNORECASE):
                self.rate_limiter.block_ip(client_ip, 3600)  # å°ç¦1å°æ—¶
                return {'blocked': True, 'reason': 'Malicious pattern detected'}
        
        return {'blocked': False}

def require_api_key(f):
    """API å¯†é’¥éªŒè¯è£…é¥°å™¨"""
    @wraps(f)
    def decorated_function(*args, **kwargs):
        api_key = request.headers.get('X-API-Key')
        
        if not api_key:
            return jsonify({'error': 'API key required'}), 401
        
        # éªŒè¯ API å¯†é’¥
        if not validate_api_key(api_key):
            return jsonify({'error': 'Invalid API key'}), 401
        
        return f(*args, **kwargs)
    return decorated_function

def validate_api_key(api_key):
    """éªŒè¯ API å¯†é’¥"""
    # ä»æ•°æ®åº“æˆ–é…ç½®ä¸­è·å–æœ‰æ•ˆçš„ API å¯†é’¥
    valid_keys = get_valid_api_keys()
    
    # ä½¿ç”¨å“ˆå¸Œæ¯”è¾ƒé¿å…æ—¶åºæ”»å‡»
    api_key_hash = hashlib.sha256(api_key.encode()).hexdigest()
    
    for valid_key in valid_keys:
        valid_key_hash = hashlib.sha256(valid_key.encode()).hexdigest()
        if api_key_hash == valid_key_hash:
            return True
    
    return False
```

## åŸºç¡€è®¾æ–½å®‰å…¨

### å®¹å™¨å®‰å…¨

#### Docker å®‰å…¨é…ç½®
```dockerfile
# Dockerfile.secure
FROM node:16-alpine AS builder

# åˆ›å»ºé root ç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶ä¾èµ–æ–‡ä»¶
COPY package*.json ./

# å®‰è£…ä¾èµ–ï¼ˆä»…ç”Ÿäº§ä¾èµ–ï¼‰
RUN npm ci --only=production && npm cache clean --force

# å¤åˆ¶æºä»£ç 
COPY . .

# æ„å»ºåº”ç”¨
RUN npm run build

# ç”Ÿäº§é•œåƒ
FROM node:16-alpine AS runner

# å®‰å…¨æ›´æ–°
RUN apk update && apk upgrade

# åˆ›å»ºç”¨æˆ·
RUN addgroup -g 1001 -S nodejs
RUN adduser -S nextjs -u 1001

# è®¾ç½®å·¥ä½œç›®å½•
WORKDIR /app

# å¤åˆ¶æ„å»ºäº§ç‰©
COPY --from=builder --chown=nextjs:nodejs /app/dist ./dist
COPY --from=builder --chown=nextjs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nextjs:nodejs /app/package.json ./package.json

# åˆ‡æ¢åˆ°é root ç”¨æˆ·
USER nextjs

# æš´éœ²ç«¯å£
EXPOSE 3000

# å¥åº·æ£€æŸ¥
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
    CMD curl -f http://localhost:3000/health || exit 1

# å¯åŠ¨åº”ç”¨
CMD ["npm", "start"]
```

#### Kubernetes å®‰å…¨ç­–ç•¥
```yaml
# pod-security-policy.yaml
apiVersion: policy/v1beta1
kind: PodSecurityPolicy
metadata:
  name: chronoretrace-psp
spec:
  privileged: false
  allowPrivilegeEscalation: false
  requiredDropCapabilities:
    - ALL
  volumes:
    - 'configMap'
    - 'emptyDir'
    - 'projected'
    - 'secret'
    - 'downwardAPI'
    - 'persistentVolumeClaim'
  hostNetwork: false
  hostIPC: false
  hostPID: false
  runAsUser:
    rule: 'MustRunAsNonRoot'
  seLinux:
    rule: 'RunAsAny'
  fsGroup:
    rule: 'RunAsAny'
  readOnlyRootFilesystem: true
---
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: chronoretrace-network-policy
  namespace: chronoretrace
spec:
  podSelector:
    matchLabels:
      app: chronoretrace
  policyTypes:
  - Ingress
  - Egress
  ingress:
  - from:
    - namespaceSelector:
        matchLabels:
          name: ingress-nginx
    ports:
    - protocol: TCP
      port: 8000
  egress:
  - to:
    - podSelector:
        matchLabels:
          app: postgres
    ports:
    - protocol: TCP
      port: 5432
  - to: []
    ports:
    - protocol: TCP
      port: 53
    - protocol: UDP
      port: 53
```

### ç³»ç»ŸåŠ å›º

#### Linux ç³»ç»ŸåŠ å›ºè„šæœ¬
```bash
#!/bin/bash
# system_hardening.sh

set -e

echo "å¼€å§‹ç³»ç»Ÿå®‰å…¨åŠ å›º..."

# æ›´æ–°ç³»ç»Ÿ
apt update && apt upgrade -y

# å®‰è£…å®‰å…¨å·¥å…·
apt install -y fail2ban ufw rkhunter chkrootkit lynis

# é…ç½®é˜²ç«å¢™
ufw default deny incoming
ufw default allow outgoing
ufw allow ssh
ufw allow 80/tcp
ufw allow 443/tcp
ufw --force enable

# é…ç½® SSH å®‰å…¨
cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup
cat > /etc/ssh/sshd_config << EOF
Port 22
Protocol 2
PermitRootLogin no
PasswordAuthentication no
PubkeyAuthentication yes
AuthorizedKeysFile .ssh/authorized_keys
PermitEmptyPasswords no
ChallengeResponseAuthentication no
UsePAM yes
X11Forwarding no
PrintMotd no
AcceptEnv LANG LC_*
Subsystem sftp /usr/lib/openssh/sftp-server
MaxAuthTries 3
ClientAliveInterval 300
ClientAliveCountMax 2
AllowUsers chronoretrace
EOF

systemctl restart sshd

# é…ç½® fail2ban
cat > /etc/fail2ban/jail.local << EOF
[DEFAULT]
bantime = 3600
findtime = 600
maxretry = 3

[sshd]
enabled = true
port = ssh
logpath = /var/log/auth.log
maxretry = 3

[nginx-http-auth]
enabled = true
filter = nginx-http-auth
logpath = /var/log/nginx/error.log
maxretry = 3

[nginx-limit-req]
enabled = true
filter = nginx-limit-req
logpath = /var/log/nginx/error.log
maxretry = 3
EOF

systemctl enable fail2ban
systemctl start fail2ban

# è®¾ç½®æ–‡ä»¶æƒé™
chmod 700 /root
chmod 600 /etc/ssh/sshd_config
chmod 644 /etc/passwd
chmod 600 /etc/shadow
chmod 644 /etc/group

# ç¦ç”¨ä¸å¿…è¦çš„æœåŠ¡
systemctl disable avahi-daemon
systemctl disable cups
systemctl disable bluetooth

# é…ç½®å†…æ ¸å‚æ•°
cat >> /etc/sysctl.conf << EOF
# ç½‘ç»œå®‰å…¨
net.ipv4.conf.all.send_redirects = 0
net.ipv4.conf.default.send_redirects = 0
net.ipv4.conf.all.accept_redirects = 0
net.ipv4.conf.default.accept_redirects = 0
net.ipv4.conf.all.secure_redirects = 0
net.ipv4.conf.default.secure_redirects = 0
net.ipv4.ip_forward = 0
net.ipv4.conf.all.log_martians = 1
net.ipv4.conf.default.log_martians = 1
net.ipv4.icmp_echo_ignore_broadcasts = 1
net.ipv4.icmp_ignore_bogus_error_responses = 1
net.ipv4.tcp_syncookies = 1

# å†…å­˜ä¿æŠ¤
kernel.dmesg_restrict = 1
kernel.kptr_restrict = 2
kernel.yama.ptrace_scope = 1
EOF

sysctl -p

# é…ç½®æ—¥å¿—å®¡è®¡
apt install -y auditd
cat > /etc/audit/rules.d/audit.rules << EOF
# ç›‘æ§é‡è¦æ–‡ä»¶
-w /etc/passwd -p wa -k identity
-w /etc/group -p wa -k identity
-w /etc/shadow -p wa -k identity
-w /etc/sudoers -p wa -k identity
-w /etc/ssh/sshd_config -p wa -k sshd

# ç›‘æ§ç³»ç»Ÿè°ƒç”¨
-a always,exit -F arch=b64 -S adjtimex -S settimeofday -k time-change
-a always,exit -F arch=b64 -S clock_settime -k time-change
-w /etc/localtime -p wa -k time-change

# ç›‘æ§ç½‘ç»œé…ç½®
-w /etc/hosts -p wa -k network
-w /etc/network/ -p wa -k network

# ç›‘æ§ç™»å½•äº‹ä»¶
-w /var/log/faillog -p wa -k logins
-w /var/log/lastlog -p wa -k logins
-w /var/log/tallylog -p wa -k logins
EOF

systemctl enable auditd
systemctl start auditd

echo "ç³»ç»Ÿå®‰å…¨åŠ å›ºå®Œæˆï¼"
```

## ç›‘æ§ä¸å®¡è®¡

### å®‰å…¨ç›‘æ§

#### å®‰å…¨äº‹ä»¶ç›‘æ§
```python
# security_monitoring.py
import re
import json
import time
from datetime import datetime
from collections import defaultdict

class SecurityMonitor:
    def __init__(self):
        self.failed_logins = defaultdict(list)
        self.suspicious_activities = []
        self.alert_thresholds = {
            'failed_login_attempts': 5,
            'failed_login_window': 300,  # 5åˆ†é’Ÿ
            'suspicious_ip_threshold': 10
        }
    
    def monitor_failed_login(self, ip_address, username, timestamp=None):
        """ç›‘æ§å¤±è´¥ç™»å½•å°è¯•"""
        if timestamp is None:
            timestamp = time.time()
        
        # è®°å½•å¤±è´¥ç™»å½•
        self.failed_logins[ip_address].append({
            'username': username,
            'timestamp': timestamp
        })
        
        # æ¸…ç†è¿‡æœŸè®°å½•
        window = self.alert_thresholds['failed_login_window']
        self.failed_logins[ip_address] = [
            attempt for attempt in self.failed_logins[ip_address]
            if timestamp - attempt['timestamp'] < window
        ]
        
        # æ£€æŸ¥æ˜¯å¦è¶…è¿‡é˜ˆå€¼
        if len(self.failed_logins[ip_address]) >= self.alert_thresholds['failed_login_attempts']:
            self.trigger_alert('brute_force_attack', {
                'ip_address': ip_address,
                'attempts': len(self.failed_logins[ip_address]),
                'usernames': [attempt['username'] for attempt in self.failed_logins[ip_address]]
            })
    
    def monitor_suspicious_activity(self, activity_type, details):
        """ç›‘æ§å¯ç–‘æ´»åŠ¨"""
        event = {
            'type': activity_type,
            'details': details,
            'timestamp': time.time()
        }
        
        self.suspicious_activities.append(event)
        
        # è§¦å‘ç›¸åº”çš„å‘Šè­¦
        if activity_type == 'sql_injection_attempt':
            self.trigger_alert('sql_injection', details)
        elif activity_type == 'xss_attempt':
            self.trigger_alert('xss_attack', details)
        elif activity_type == 'privilege_escalation':
            self.trigger_alert('privilege_escalation', details)
    
    def trigger_alert(self, alert_type, details):
        """è§¦å‘å®‰å…¨å‘Šè­¦"""
        alert = {
            'type': alert_type,
            'details': details,
            'timestamp': datetime.now().isoformat(),
            'severity': self.get_alert_severity(alert_type)
        }
        
        # è®°å½•å‘Šè­¦
        self.log_security_alert(alert)
        
        # å‘é€é€šçŸ¥
        self.send_security_notification(alert)
    
    def get_alert_severity(self, alert_type):
        """è·å–å‘Šè­¦ä¸¥é‡çº§åˆ«"""
        severity_map = {
            'brute_force_attack': 'high',
            'sql_injection': 'critical',
            'xss_attack': 'high',
            'privilege_escalation': 'critical',
            'data_breach': 'critical',
            'unauthorized_access': 'high'
        }
        return severity_map.get(alert_type, 'medium')
    
    def log_security_alert(self, alert):
        """è®°å½•å®‰å…¨å‘Šè­¦"""
        log_entry = {
            'timestamp': alert['timestamp'],
            'level': 'SECURITY_ALERT',
            'type': alert['type'],
            'severity': alert['severity'],
            'details': alert['details']
        }
        
        # å†™å…¥å®‰å…¨æ—¥å¿—
        with open('/var/log/chronoretrace/security.log', 'a') as f:
            f.write(json.dumps(log_entry) + '\n')
    
    def send_security_notification(self, alert):
        """å‘é€å®‰å…¨é€šçŸ¥"""
        if alert['severity'] in ['critical', 'high']:
            # å‘é€ç´§æ€¥é€šçŸ¥
            self.send_emergency_notification(alert)
        else:
            # å‘é€å¸¸è§„é€šçŸ¥
            self.send_regular_notification(alert)
    
    def analyze_log_patterns(self, log_file):
        """åˆ†ææ—¥å¿—æ¨¡å¼"""
        patterns = {
            'sql_injection': r'(union|select|insert|update|delete|drop).*?(from|into|table)',
            'xss_attack': r'<script[^>]*>.*?</script>',
            'path_traversal': r'\.\./',
            'command_injection': r'(;|\||&|`|\$\()',
            'brute_force': r'authentication failed|invalid password|login failed'
        }
        
        with open(log_file, 'r') as f:
            for line in f:
                for pattern_name, pattern in patterns.items():
                    if re.search(pattern, line, re.IGNORECASE):
                        self.monitor_suspicious_activity(pattern_name, {
                            'log_line': line.strip(),
                            'pattern': pattern_name
                        })
```

### å®¡è®¡æ—¥å¿—

#### å®¡è®¡æ—¥å¿—é…ç½®
```python
# audit_logging.py
import json
import time
from datetime import datetime
from functools import wraps
from flask import request, g

class AuditLogger:
    def __init__(self, log_file='/var/log/chronoretrace/audit.log'):
        self.log_file = log_file
    
    def log_event(self, event_type, details, user_id=None, ip_address=None):
        """è®°å½•å®¡è®¡äº‹ä»¶"""
        audit_entry = {
            'timestamp': datetime.now().isoformat(),
            'event_type': event_type,
            'user_id': user_id,
            'ip_address': ip_address or self.get_client_ip(),
            'details': details,
            'session_id': getattr(g, 'session_id', None)
        }
        
        with open(self.log_file, 'a') as f:
            f.write(json.dumps(audit_entry) + '\n')
    
    def get_client_ip(self):
        """è·å–å®¢æˆ·ç«¯ IP"""
        if request:
            return request.environ.get('HTTP_X_FORWARDED_FOR', request.remote_addr)
        return None

def audit_action(action_type):
    """å®¡è®¡è£…é¥°å™¨"""
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            start_time = time.time()
            
            try:
                result = func(*args, **kwargs)
                
                # è®°å½•æˆåŠŸçš„æ“ä½œ
                audit_logger.log_event(
                    event_type=f'{action_type}_success',
                    details={
                        'function': func.__name__,
                        'args': str(args),
                        'kwargs': str(kwargs),
                        'execution_time': time.time() - start_time
                    },
                    user_id=getattr(g, 'user_id', None)
                )
                
                return result
                
            except Exception as e:
                # è®°å½•å¤±è´¥çš„æ“ä½œ
                audit_logger.log_event(
                    event_type=f'{action_type}_failure',
                    details={
                        'function': func.__name__,
                        'args': str(args),
                        'kwargs': str(kwargs),
                        'error': str(e),
                        'execution_time': time.time() - start_time
                    },
                    user_id=getattr(g, 'user_id', None)
                )
                raise
        
        return wrapper
    return decorator

# å…¨å±€å®¡è®¡æ—¥å¿—å®ä¾‹
audit_logger = AuditLogger()

# ä½¿ç”¨ç¤ºä¾‹
@audit_action('user_login')
def user_login(username, password):
    # ç™»å½•é€»è¾‘
    pass

@audit_action('data_access')
def get_user_data(user_id):
    # æ•°æ®è®¿é—®é€»è¾‘
    pass

@audit_action('admin_operation')
def delete_user(user_id):
    # ç®¡ç†å‘˜æ“ä½œé€»è¾‘
    pass
```

## åˆè§„è¦æ±‚

### GDPR åˆè§„

#### æ•°æ®ä¿æŠ¤å®ç°
```python
# gdpr_compliance.py
from datetime import datetime, timedelta
import json

class GDPRCompliance:
    def __init__(self):
        self.data_retention_periods = {
            'user_data': 365 * 2,      # 2å¹´
            'log_data': 365,           # 1å¹´
            'session_data': 30,        # 30å¤©
            'analytics_data': 365 * 3  # 3å¹´
        }
    
    def handle_data_subject_request(self, request_type, user_id, details=None):
        """å¤„ç†æ•°æ®ä¸»ä½“è¯·æ±‚"""
        if request_type == 'access':
            return self.export_user_data(user_id)
        elif request_type == 'rectification':
            return self.update_user_data(user_id, details)
        elif request_type == 'erasure':
            return self.delete_user_data(user_id)
        elif request_type == 'portability':
            return self.export_portable_data(user_id)
        elif request_type == 'restriction':
            return self.restrict_data_processing(user_id)
        else:
            raise ValueError(f'Unknown request type: {request_type}')
    
    def export_user_data(self, user_id):
        """å¯¼å‡ºç”¨æˆ·æ•°æ®ï¼ˆGDPR ç¬¬15æ¡ï¼‰"""
        user_data = {
            'personal_data': self.get_personal_data(user_id),
            'processing_purposes': self.get_processing_purposes(user_id),
            'data_categories': self.get_data_categories(user_id),
            'recipients': self.get_data_recipients(user_id),
            'retention_period': self.get_retention_period(user_id),
            'data_source': self.get_data_source(user_id),
            'automated_decision_making': self.get_automated_decisions(user_id)
        }
        
        # è®°å½•æ•°æ®å¯¼å‡ºè¯·æ±‚
        self.log_gdpr_request('data_export', user_id, user_data)
        
        return user_data
    
    def delete_user_data(self, user_id):
        """åˆ é™¤ç”¨æˆ·æ•°æ®ï¼ˆGDPR ç¬¬17æ¡ï¼‰"""
        try:
            # åˆ é™¤ä¸ªäººæ•°æ®
            self.delete_personal_data(user_id)
            
            # åˆ é™¤å…³è”æ•°æ®
            self.delete_user_sessions(user_id)
            self.delete_user_logs(user_id)
            self.anonymize_user_analytics(user_id)
            
            # è®°å½•åˆ é™¤æ“ä½œ
            self.log_gdpr_request('data_erasure', user_id, {'status': 'completed'})
            
            return {'status': 'success', 'message': 'User data deleted successfully'}
            
        except Exception as e:
            self.log_gdpr_request('data_erasure', user_id, {'status': 'failed', 'error': str(e)})
            raise
    
    def check_data_retention(self):
        """æ£€æŸ¥æ•°æ®ä¿ç•™æœŸé™"""
        expired_data = []
        
        for data_type, retention_days in self.data_retention_periods.items():
            cutoff_date = datetime.now() - timedelta(days=retention_days)
            expired_records = self.find_expired_data(data_type, cutoff_date)
            
            if expired_records:
                expired_data.append({
                    'data_type': data_type,
                    'count': len(expired_records),
                    'cutoff_date': cutoff_date.isoformat()
                })
        
        return expired_data
    
    def auto_delete_expired_data(self):
        """è‡ªåŠ¨åˆ é™¤è¿‡æœŸæ•°æ®"""
        expired_data = self.check_data_retention()
        
        for data_info in expired_data:
            data_type = data_info['data_type']
            cutoff_date = datetime.fromisoformat(data_info['cutoff_date'])
            
            deleted_count = self.delete_expired_data(data_type, cutoff_date)
            
            self.log_gdpr_request('auto_deletion', None, {
                 'data_type': data_type,
                 'deleted_count': deleted_count,
                 'cutoff_date': cutoff_date.isoformat()
             })

## å®‰å…¨äº‹ä»¶å“åº”

### äº‹ä»¶å“åº”æµç¨‹

#### å®‰å…¨äº‹ä»¶åˆ†ç±»
```python
# incident_response.py
from enum import Enum
from datetime import datetime
import json

class IncidentSeverity(Enum):
    LOW = 'low'
    MEDIUM = 'medium'
    HIGH = 'high'
    CRITICAL = 'critical'

class IncidentType(Enum):
    DATA_BREACH = 'data_breach'
    MALWARE = 'malware'
    DDOS = 'ddos'
    UNAUTHORIZED_ACCESS = 'unauthorized_access'
    SYSTEM_COMPROMISE = 'system_compromise'
    INSIDER_THREAT = 'insider_threat'

class IncidentResponse:
    def __init__(self):
        self.response_team = {
            'incident_commander': 'security@chronoretrace.com',
            'technical_lead': 'tech-lead@chronoretrace.com',
            'communications': 'pr@chronoretrace.com',
            'legal': 'legal@chronoretrace.com'
        }
        
        self.escalation_matrix = {
            IncidentSeverity.CRITICAL: {
                'response_time': 15,  # åˆ†é’Ÿ
                'notification_list': ['ceo', 'cto', 'security_team', 'legal']
            },
            IncidentSeverity.HIGH: {
                'response_time': 60,
                'notification_list': ['cto', 'security_team']
            },
            IncidentSeverity.MEDIUM: {
                'response_time': 240,
                'notification_list': ['security_team']
            },
            IncidentSeverity.LOW: {
                'response_time': 1440,  # 24å°æ—¶
                'notification_list': ['security_team']
            }
        }
    
    def create_incident(self, incident_type, severity, description, affected_systems=None):
        """åˆ›å»ºå®‰å…¨äº‹ä»¶"""
        incident = {
            'id': self.generate_incident_id(),
            'type': incident_type.value,
            'severity': severity.value,
            'description': description,
            'affected_systems': affected_systems or [],
            'created_at': datetime.now().isoformat(),
            'status': 'open',
            'assigned_to': None,
            'timeline': []
        }
        
        # ç«‹å³å“åº”
        self.initiate_response(incident)
        
        return incident
    
    def initiate_response(self, incident):
        """å¯åŠ¨äº‹ä»¶å“åº”"""
        severity = IncidentSeverity(incident['severity'])
        
        # å‘é€é€šçŸ¥
        self.send_incident_notifications(incident, severity)
        
        # æ‰§è¡Œè‡ªåŠ¨å“åº”
        self.execute_automated_response(incident)
        
        # è®°å½•å“åº”å¼€å§‹
         self.add_timeline_entry(incident, 'response_initiated', {
             'responder': 'system',
             'action': 'Automated response initiated'
         })
```

### åº”æ€¥å“åº”æ‰‹å†Œ

#### æ•°æ®æ³„éœ²å“åº”
```bash
#!/bin/bash
# data_breach_response.sh

echo "æ•°æ®æ³„éœ²åº”æ€¥å“åº”ç¨‹åºå¯åŠ¨..."

# 1. ç«‹å³éš”ç¦»å—å½±å“ç³»ç»Ÿ
echo "æ­¥éª¤1: éš”ç¦»å—å½±å“ç³»ç»Ÿ"
iptables -A INPUT -s $SUSPICIOUS_IP -j DROP
iptables -A OUTPUT -d $SUSPICIOUS_IP -j DROP

# 2. ä¿å­˜è¯æ®
echo "æ­¥éª¤2: ä¿å­˜è¯æ®"
mkdir -p /var/log/incident_$(date +%Y%m%d_%H%M%S)
cp /var/log/nginx/access.log /var/log/incident_$(date +%Y%m%d_%H%M%S)/
cp /var/log/auth.log /var/log/incident_$(date +%Y%m%d_%H%M%S)/
cp /var/log/syslog /var/log/incident_$(date +%Y%m%d_%H%M%S)/

# 3. é€šçŸ¥ç›¸å…³äººå‘˜
echo "æ­¥éª¤3: å‘é€é€šçŸ¥"
curl -X POST "$SLACK_WEBHOOK" \
  -H 'Content-type: application/json' \
  --data '{"text":"ğŸš¨ æ•°æ®æ³„éœ²äº‹ä»¶æ£€æµ‹åˆ°ï¼Œè¯·ç«‹å³å“åº”ï¼"}'

# 4. å¯åŠ¨å¤‡ä»½ç³»ç»Ÿ
echo "æ­¥éª¤4: å¯åŠ¨å¤‡ä»½ç³»ç»Ÿ"
docker-compose -f docker-compose.backup.yml up -d

# 5. æ›´æ”¹æ‰€æœ‰å¯†ç å’Œå¯†é’¥
echo "æ­¥éª¤5: è½®æ¢å¯†é’¥"
python /scripts/rotate_secrets.py --emergency

echo "åº”æ€¥å“åº”ç¨‹åºå®Œæˆï¼Œè¯·æŸ¥çœ‹è¯¦ç»†æ—¥å¿—"
```

## å®‰å…¨æµ‹è¯•

### æ¸—é€æµ‹è¯•

#### è‡ªåŠ¨åŒ–å®‰å…¨æ‰«æ
```python
# security_scanner.py
import requests
import subprocess
import json
from urllib.parse import urljoin

class SecurityScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.vulnerabilities = []
    
    def scan_sql_injection(self):
        """SQL æ³¨å…¥æ‰«æ"""
        payloads = [
            "' OR '1'='1",
            "'; DROP TABLE users; --",
            "' UNION SELECT * FROM users --",
            "1' AND 1=1 --",
            "1' AND 1=2 --"
        ]
        
        test_endpoints = [
            '/api/users',
            '/api/search',
            '/login',
            '/api/data'
        ]
        
        for endpoint in test_endpoints:
            for payload in payloads:
                url = urljoin(self.target_url, endpoint)
                
                # GET å‚æ•°æµ‹è¯•
                response = requests.get(url, params={'q': payload})
                if self.detect_sql_error(response.text):
                    self.vulnerabilities.append({
                        'type': 'SQL Injection',
                        'severity': 'High',
                        'endpoint': endpoint,
                        'payload': payload,
                        'method': 'GET'
                    })
                
                # POST æ•°æ®æµ‹è¯•
                response = requests.post(url, data={'input': payload})
                if self.detect_sql_error(response.text):
                    self.vulnerabilities.append({
                        'type': 'SQL Injection',
                        'severity': 'High',
                        'endpoint': endpoint,
                        'payload': payload,
                        'method': 'POST'
                    })
    
    def scan_xss(self):
        """XSS æ‰«æ"""
        payloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>"
        ]
        
        for payload in payloads:
            response = requests.post(
                urljoin(self.target_url, '/api/comment'),
                data={'content': payload}
            )
            
            if payload in response.text and 'text/html' in response.headers.get('content-type', ''):
                self.vulnerabilities.append({
                    'type': 'XSS',
                    'severity': 'Medium',
                    'payload': payload,
                    'reflected': True
                })
    
    def scan_directory_traversal(self):
        """ç›®å½•éå†æ‰«æ"""
        payloads = [
            '../../../etc/passwd',
            '..\\..\\..\\windows\\system32\\drivers\\etc\\hosts',
            '/etc/passwd',
            '/proc/version',
            '/etc/shadow'
        ]
        
        for payload in payloads:
            response = requests.get(
                urljoin(self.target_url, '/api/file'),
                params={'path': payload}
            )
            
            if 'root:' in response.text or 'daemon:' in response.text:
                self.vulnerabilities.append({
                    'type': 'Directory Traversal',
                    'severity': 'High',
                    'payload': payload,
                    'file_accessed': True
                })
    
    def detect_sql_error(self, response_text):
        """æ£€æµ‹ SQL é”™è¯¯"""
        error_patterns = [
            'mysql_fetch_array',
            'ORA-01756',
            'Microsoft OLE DB Provider',
            'PostgreSQL query failed',
            'SQLite error',
            'syntax error'
        ]
        
        return any(pattern.lower() in response_text.lower() for pattern in error_patterns)
    
    def generate_report(self):
        """ç”Ÿæˆæ‰«ææŠ¥å‘Š"""
        report = {
            'target': self.target_url,
            'scan_date': datetime.now().isoformat(),
            'total_vulnerabilities': len(self.vulnerabilities),
            'vulnerabilities': self.vulnerabilities,
            'summary': {
                'critical': len([v for v in self.vulnerabilities if v['severity'] == 'Critical']),
                'high': len([v for v in self.vulnerabilities if v['severity'] == 'High']),
                'medium': len([v for v in self.vulnerabilities if v['severity'] == 'Medium']),
                'low': len([v for v in self.vulnerabilities if v['severity'] == 'Low'])
            }
        }
        
        return report
```

### å®‰å…¨æœ€ä½³å®è·µ

#### å¼€å‘å®‰å…¨æ£€æŸ¥æ¸…å•

**ä»£ç å®¡æŸ¥æ£€æŸ¥é¡¹**
- [ ] è¾“å…¥éªŒè¯å’Œæ¸…ç†
- [ ] è¾“å‡ºç¼–ç 
- [ ] å‚æ•°åŒ–æŸ¥è¯¢
- [ ] é€‚å½“çš„é”™è¯¯å¤„ç†
- [ ] å®‰å…¨çš„å¯†ç å­˜å‚¨
- [ ] ä¼šè¯ç®¡ç†
- [ ] è®¿é—®æ§åˆ¶
- [ ] æ—¥å¿—è®°å½•
- [ ] åŠ å¯†å®ç°
- [ ] ä¾èµ–é¡¹å®‰å…¨

**éƒ¨ç½²å®‰å…¨æ£€æŸ¥é¡¹**
- [ ] æœ€å°æƒé™åŸåˆ™
- [ ] ç½‘ç»œåˆ†æ®µ
- [ ] é˜²ç«å¢™é…ç½®
- [ ] SSL/TLS é…ç½®
- [ ] å®‰å…¨å¤´è®¾ç½®
- [ ] æ—¥å¿—ç›‘æ§
- [ ] å¤‡ä»½ç­–ç•¥
- [ ] æ›´æ–°ç®¡ç†
- [ ] è®¿é—®å®¡è®¡
- [ ] äº‹ä»¶å“åº”è®¡åˆ’

#### å®‰å…¨é…ç½®éªŒè¯è„šæœ¬
```bash
#!/bin/bash
# security_validation.sh

echo "å¼€å§‹å®‰å…¨é…ç½®éªŒè¯..."

# æ£€æŸ¥ SSL é…ç½®
echo "æ£€æŸ¥ SSL é…ç½®..."
ssl_score=$(curl -s "https://api.ssllabs.com/api/v3/analyze?host=chronoretrace.com" | jq '.endpoints[0].grade')
echo "SSL Labs è¯„åˆ†: $ssl_score"

# æ£€æŸ¥å®‰å…¨å¤´
echo "æ£€æŸ¥å®‰å…¨å¤´..."
curl -I https://chronoretrace.com | grep -E "(Strict-Transport-Security|X-Frame-Options|X-Content-Type-Options|X-XSS-Protection|Content-Security-Policy)"

# æ£€æŸ¥å¼€æ”¾ç«¯å£
echo "æ£€æŸ¥å¼€æ”¾ç«¯å£..."
nmap -sS -O localhost

# æ£€æŸ¥æ–‡ä»¶æƒé™
echo "æ£€æŸ¥å…³é”®æ–‡ä»¶æƒé™..."
ls -la /etc/passwd /etc/shadow /etc/ssh/sshd_config

# æ£€æŸ¥è¿è¡ŒæœåŠ¡
echo "æ£€æŸ¥è¿è¡ŒæœåŠ¡..."
systemctl list-units --type=service --state=running

# æ£€æŸ¥é˜²ç«å¢™çŠ¶æ€
echo "æ£€æŸ¥é˜²ç«å¢™çŠ¶æ€..."
ufw status verbose

# æ£€æŸ¥å¤±è´¥ç™»å½•
echo "æ£€æŸ¥æœ€è¿‘å¤±è´¥ç™»å½•..."
lastb | head -10

# æ£€æŸ¥ç³»ç»Ÿæ›´æ–°
echo "æ£€æŸ¥ç³»ç»Ÿæ›´æ–°..."
apt list --upgradable

echo "å®‰å…¨é…ç½®éªŒè¯å®Œæˆï¼"
```

## æ€»ç»“

æœ¬å®‰å…¨é…ç½®æŒ‡å—æ¶µç›–äº† ChronoRetrace åº”ç”¨çš„å…¨é¢å®‰å…¨æªæ–½ï¼ŒåŒ…æ‹¬ï¼š

1. **èº«ä»½è®¤è¯ä¸æˆæƒ**: JWT è®¤è¯ã€å¤šå› ç´ è®¤è¯ã€åŸºäºè§’è‰²çš„è®¿é—®æ§åˆ¶
2. **ç½‘ç»œå®‰å…¨**: é˜²ç«å¢™é…ç½®ã€WAF ä¿æŠ¤ã€TLS/SSL åŠ å¯†
3. **æ•°æ®ä¿æŠ¤**: æ•°æ®åŠ å¯†ã€æ•°æ®è„±æ•ã€GDPR åˆè§„
4. **åº”ç”¨å®‰å…¨**: è¾“å…¥éªŒè¯ã€API å®‰å…¨ã€å®‰å…¨ç¼–ç å®è·µ
5. **åŸºç¡€è®¾æ–½å®‰å…¨**: å®¹å™¨å®‰å…¨ã€ç³»ç»ŸåŠ å›ºã€å®‰å…¨ç›‘æ§
6. **äº‹ä»¶å“åº”**: å®‰å…¨ç›‘æ§ã€å®¡è®¡æ—¥å¿—ã€åº”æ€¥å“åº”
7. **åˆè§„è¦æ±‚**: GDPR å®æ–½ã€æ•°æ®ä¿æŠ¤ã€éšç§ç®¡ç†
8. **å®‰å…¨æµ‹è¯•**: æ¸—é€æµ‹è¯•ã€æ¼æ´æ‰«æã€å®‰å…¨éªŒè¯

**é‡è¦æé†’**:
- å®šæœŸæ›´æ–°å®‰å…¨é…ç½®å’Œç­–ç•¥
- æŒç»­ç›‘æ§å’Œå®¡è®¡å®‰å…¨äº‹ä»¶
- å®šæœŸè¿›è¡Œå®‰å…¨åŸ¹è®­å’Œæ¼”ç»ƒ
- ä¿æŒå®‰å…¨å·¥å…·å’Œç³»ç»Ÿçš„æœ€æ–°çŠ¶æ€
- å»ºç«‹å®Œå–„çš„äº‹ä»¶å“åº”æµç¨‹

éµå¾ªæœ¬æŒ‡å—çš„å®‰å…¨æªæ–½ï¼Œå¯ä»¥æœ‰æ•ˆä¿æŠ¤ ChronoRetrace åº”ç”¨å…å—å„ç§å®‰å…¨å¨èƒï¼Œç¡®ä¿ç”¨æˆ·æ•°æ®å’Œç³»ç»Ÿçš„å®‰å…¨æ€§ã€‚
```}]},"query_language":"Chinese"}}