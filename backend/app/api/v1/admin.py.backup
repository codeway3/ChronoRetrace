from __future__ import annotations

from datetime import datetime

from fastapi import APIRouter, Depends, HTTPException, Query, Request, status
from fastapi_cache import FastAPICache
from redis import asyncio as aioredis
from sqlalchemy import func
from sqlalchemy.orm import Session

from app.core.config import settings
from app.core.security import log_user_activity, require_admin
from app.data.managers import database_admin as db_admin
from app.infrastructure.database.models import (
from typing import Union

    User,
    UserActivityLog,
    UserPreferences,
    UserRole,
    UserRoleAssignment,
    UserSession,
)
from app.infrastructure.database.session import get_db
from app.schemas.auth_schemas import (
    ApiResponse,
    PaginatedResponse,
    UserResponse,
    UserSessionResponse,
    UserUpdate,
)
from app.services.auth_service import auth_service

router = APIRouter()


@router.get("/redis-health", status_code=200)
async def redis_health_check():
    """
    Checks the health of the Redis connection.
    """
    try:
        redis = await aioredis.from_url(settings.REDIS_URL)
        await redis.ping()
        await redis.close()
        return {"status": "ok", "message": "Redis connection is healthy."}
    except Exception as e:
        raise HTTPException(
            status_code=503,
            detail={
                "status": "error",
                "message": "Redis connection failed.",
                "error_details": str(e),
            },
        ) from e


@router.post("/clear-cache", status_code=200)
async def clear_cache(db: Session = Depends(get_db)):
    """
    Endpoint to clear all cached financial data from the database and Redis.
    Intended for development and testing purposes.
    """
    try:
        # Clear database cache
        db_result = db_admin.clear_all_financial_data(db)

        # Clear Redis cache
        await FastAPICache.clear()

        db_result["message"] = (
            "All database and Redis cache has been cleared successfully."
        )
        return db_result

    except Exception as e:
        raise HTTPException(
            status_code=500,
            detail={
                "status": "error",
                "message": "Failed to clear cache.",
                "error_details": str(e),
            },
        ) from e


@router.post("/init-admin", response_model=ApiResponse)
async def initialize_admin_account(request: Request, db: Session = Depends(get_db)):
    """初始化默认管理员账号"""
    try:
        # 检查是否已存在管理员
        admin_role = db.query(UserRole).filter(UserRole.name == "admin").first()
        if admin_role:
            admin_exists = (
                db.query(UserRoleAssignment)
                .filter(UserRoleAssignment.role_id == admin_role.id)
                .first()
            )
            if admin_exists:
                return ApiResponse(success=False, message="管理员账号已存在")

        # 创建角色（如果不存在）
        roles_to_create = [
            {"name": "admin", "description": "系统管理员", "permissions": "*"},
            {"name": "moderator", "description": "版主", "permissions": "moderate"},
            {"name": "user", "description": "普通用户", "permissions": "read"},
        ]

        for role_data in roles_to_create:
            existing_role = (
                db.query(UserRole).filter(UserRole.name == role_data["name"]).first()
            )
            if not existing_role:
                new_role = UserRole(
                    name=role_data["name"],
                    description=role_data["description"],
                    permissions=role_data["permissions"],
                )
                db.add(new_role)

        db.commit()

        # 创建默认管理员用户
        admin_username = "admin"
        admin_email = "admin@chronoretrace.com"
        admin_password = "ChronoAdmin2024!"  # 生产环境中应该使用更安全的密码

        # 检查管理员用户是否已存在
        existing_admin = (
            db.query(User)
            .filter((User.username == admin_username) | (User.email == admin_email))
            .first()
        )

        if existing_admin:
            return ApiResponse(success=False, message="管理员用户已存在")

        # 创建管理员用户
        hashed_password = auth_service.hash_password(admin_password)
        admin_user = User(
            username=admin_username,
            email=admin_email,
            full_name="系统管理员",
            password_hash=hashed_password,
            is_active=True,
        )

        db.add(admin_user)
        db.commit()
        db.refresh(admin_user)

        # 分配管理员角色
        admin_role = db.query(UserRole).filter(UserRole.name == "admin").first()
        if admin_role:
            role_assignment = UserRoleAssignment(
                user_id=admin_user.id, role_id=admin_role.id
            )
            db.add(role_assignment)

        # 创建默认偏好设置
        admin_preferences = UserPreferences(
            user_id=admin_user.id,
            theme_mode="dark",
            language="zh-CN",
            timezone="Asia/Shanghai",
            email_notifications=True,
            push_notifications=False,
        )
        db.add(admin_preferences)
        db.commit()

        # 记录管理员创建活动
        log_user_activity(
            admin_user, "admin_account_created", "默认管理员账号初始化", request, db
        )

        return ApiResponse(
            success=True,
            message="默认管理员账号创建成功",
            data={
                "username": admin_username,
                "email": admin_email,
                "password": admin_password,  # 仅在开发环境返回
                "note": "请立即修改默认密码",
            },
        )

    except Exception as e:
        db.rollback()
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"创建管理员账号失败: {str(e)}",
        ) from None


@router.get("/users", response_model=PaginatedResponse)
async def get_users(
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    search: Union[str, None] = Query(None),
    is_active: Union[bool, None] = Query(None),
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """获取用户列表（分页）"""
    query = db.query(User)

    # 搜索过滤
    if search:
        query = query.filter(
            (User.username.contains(search))
            | (User.email.contains(search))
            | (User.full_name.contains(search))
        )

    # 状态过滤
    if is_active is not None:
        query = query.filter(User.is_active == is_active)

    # 计算总数
    total = query.count()

    # 分页
    offset = (page - 1) * size
    users = query.offset(offset).limit(size).all()

    # 转换为响应格式
    user_data = []
    for user in users:
        user_dict = {
            "id": user.id,
            "username": user.username,
            "email": user.email,
            "full_name": user.full_name,
            "is_active": user.is_active,
            "created_at": user.created_at.isoformat(),
            "last_login": user.last_login.isoformat() if user.last_login else None,
        }
        user_data.append(user_dict)

    pages = (total + size - 1) // size

    return PaginatedResponse(
        items=user_data, total=total, page=page, size=size, pages=pages
    )


@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """获取用户详情"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="用户不存在")

    return user


@router.put("/users/{user_id}", response_model=UserResponse)
async def update_user(
    user_id: int,
    user_update: UserUpdate,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """更新用户信息"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="用户不存在")

    # 更新用户信息
    update_data = user_update.dict(exclude_unset=True)
    for field, value in update_data.items():
        setattr(user, field, value)

    user.updated_at = datetime.utcnow()
    db.commit()
    db.refresh(user)

    # 记录管理员操作
    log_user_activity(
        current_user,
        "admin_user_updated",
        f"更新用户 {user.username} 信息: {update_data}",
        request,
        db,
    )

    return user


@router.delete("/users/{user_id}", response_model=ApiResponse)
async def delete_user(
    user_id: int,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """删除用户（软删除）"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="用户不存在")

    # 防止删除管理员自己
    if user.id == current_user.id:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST, detail="不能删除自己的账号"
        )

    # 软删除（设置为非活跃状态）
    user.is_active = False
    user.updated_at = datetime.utcnow()
    db.commit()

    # 记录管理员操作
    log_user_activity(
        current_user, "admin_user_deleted", f"删除用户 {user.username}", request, db
    )

    return ApiResponse(success=True, message="用户删除成功")


@router.get("/users/{user_id}/sessions", response_model=list[UserSessionResponse])
async def get_user_sessions(
    user_id: int,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """获取用户会话列表"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="用户不存在")

    sessions = (
        db.query(UserSession)
        .filter(UserSession.user_id == user_id)
        .order_by(UserSession.created_at.desc())
        .all()
    )

    return sessions


@router.delete("/users/{user_id}/sessions/{session_id}", response_model=ApiResponse)
async def revoke_user_session(
    user_id: int,
    session_id: int,
    request: Request,
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """撤销用户会话"""
    session = (
        db.query(UserSession)
        .filter(UserSession.id == session_id, UserSession.user_id == user_id)
        .first()
    )

    if not session:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="会话不存在")

    session.is_active = False
    db.commit()

    # 记录管理员操作
    log_user_activity(
        current_user,
        "admin_session_revoked",
        f"撤销用户 {user_id} 的会话 {session_id}",
        request,
        db,
    )

    return ApiResponse(success=True, message="会话撤销成功")


@router.get("/users/{user_id}/activities", response_model=PaginatedResponse)
async def get_user_activities(
    user_id: int,
    page: int = Query(1, ge=1),
    size: int = Query(20, ge=1, le=100),
    current_user: User = Depends(require_admin),
    db: Session = Depends(get_db),
):
    """获取用户活动日志"""
    user = db.query(User).filter(User.id == user_id).first()
    if not user:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="用户不存在")

    query = db.query(UserActivityLog).filter(UserActivityLog.user_id == user_id)
    total = query.count()

    offset = (page - 1) * size
    activities = (
        query.order_by(UserActivityLog.created_at.desc())
        .offset(offset)
        .limit(size)
        .all()
    )

    activity_data = []
    for activity in activities:
        activity_dict = {
            "id": activity.id,
            "action": activity.action,
            "details": activity.details,
            "ip_address": activity.ip_address,
            "user_agent": activity.user_agent,
            "created_at": activity.created_at.isoformat(),
        }
        activity_data.append(activity_dict)

    pages = (total + size - 1) // size

    return PaginatedResponse(
        items=activity_data, total=total, page=page, size=size, pages=pages
    )


@router.get("/stats", response_model=dict)
async def get_admin_stats(
    current_user: User = Depends(require_admin), db: Session = Depends(get_db)
):
    """获取管理员统计信息"""
    # 用户统计
    total_users = db.query(User).count()
    active_users = db.query(User).filter(User.is_active).count()
    inactive_users = total_users - active_users

    # 今日新注册用户
    today = datetime.utcnow().date()
    new_users_today = db.query(User).filter(func.date(User.created_at) == today).count()

    # 活跃会话
    active_sessions = (
        db.query(UserSession)
        .filter(UserSession.is_active, UserSession.expires_at > datetime.utcnow())
        .count()
    )

    # 最近活动
    recent_activities = (
        db.query(UserActivityLog)
        .order_by(UserActivityLog.created_at.desc())
        .limit(10)
        .all()
    )

    recent_activity_data = []
    for activity in recent_activities:
        user = db.query(User).filter(User.id == activity.user_id).first()
        activity_dict = {
            "id": activity.id,
            "user_id": activity.user_id,
            "username": user.username if user else "未知用户",
            "action": activity.action,
            "created_at": activity.created_at.isoformat(),
        }
        recent_activity_data.append(activity_dict)

    return {
        "users": {
            "total": total_users,
            "active": active_users,
            "inactive": inactive_users,
            "new_today": new_users_today,
        },
        "sessions": {"active": active_sessions},
        "recent_activities": recent_activity_data,
    }
